# 프로토콜과 표준

### 프로토콜

- 네트워크 통신 규약
- 두 컴퓨터 간 메시지를 이해하기 위해 메시지 형식을 정의해놓은 것

# 프로토콜 계층 구조

## OSI 모델

각 계층 별 특징과 주요 장비(스위치, 라우터, NIC) 소개 

### 1 계층 (Physical layer)

- 물리적 연결과 관련된 정보를 정의한다.
- 주소 개념이 없고, **전기 신호를 전달하는 것**이 목적 : 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 보낸다.
- 주요 장비 :
    - 허브, 리피터 : 네트워크 통신을 중재하는 네트워크 장비
    - 케이블, 트랜시버 : 컴퓨터의 랜카드와 케이블을 연결하는 장치
    - 탭 : 네트워크 모니터링과 패킷 분석을 위해 전기 신호를 다른 장비로 복제해준다.

### 2 계층 (DataLink layer)

- 전기 신호를 모아 우리가 알아볼 수 있는 데이터 형태로 처리 (직렬화)
- **주소 정보를 정의하고 정확한 주소로 통신**이 되도록 하는 것이 목적
    - 출발지와 도착지 주로를 확인하고 내게 보낸 것이 맞는지, 또는 내가 처리해야 하는지에 대해 검사한 후 데이터 처리를 수행한다.
    - **MAC 주소 체계**
    - **플로우 컨트롤** : 주소 체계가 생긴다는 의미는 한 명과 통신하는 것이 아니라 동시에 여러 명과 통신할 수 있다는 것이므로 무작정 데이터를 던지는 것이 아니라 받는 사람이 현재 데이터를 받을 수 있는지 확인하는 작업부터 해야한다. 이 역할을 Flow Control이라고 부른다.
    
    
- 주요 장비
    - **네트워크 인터페이스 카드 (NIC)** (=네트워크 카드, 랜 카드, 이더넷 카드, 네트워크 어댑터)
    - **스위치**
    


- **스위치 동작 방식**
    
    
    - 전체 포트로 전기신호를 보내는 1계층 장비 허브와 달리, 스위치는 MAC 주소를 이해할 수 있어 목적지 MAC 주소의 위치를 파악하고 목적지가 연결된 포트로만 전기 신호를 보낸다.
    - 이로 인해 네트워크 전체에 불필요한 처리가 감소하면서 이더넷 네트워크 효율성이 크게 향상되었고 이더넷 기반 네트워크가 급증하는 계기가 됨.
    - 스위치는 단말이 어떤 MAC 주소인지, 연결된 포트는 어느 것인지 주소 습득(Address Learning) 과정에서 알 수 있다. 이 데이터를 기반으로 단말들이 통신할 때 포트를 적절히 필터링하고 정확한 포트로 포워딩해준다.
        
        
    

### 3 계층 (Network Layer)

- **IP 주소**와 같은 **논리적인 주소**가 정의됨.

<aside>
📖 데이터 통신을 할 때 2가지 주소가 사용된다. 
- 2 계층의 물리적인 MAC 주소
- 3 계층의 논리적인 IP 주소

</aside>

- MAC 주소와 달리, IP 주소는 사용자가 환경에 맞게 변경해 사용할 수 있고, 네트워크 주소 부분과 호스트 주소 부분으로 나뉜다.
- 3계층을 이해할 수 있는 장비나 단말은 네트워크 주소 정보를 이용해 자신이 속한 네트워크와 원격지 네트워크를 구분할 수 있고 원격지 네트워크를 가려면 어디로 가야 하는지 경로를 지정하는 능력이 있다.
![image](https://user-images.githubusercontent.com/47748246/159610795-f73128df-ee40-4763-a64f-9c58ea46e47a.png)

- 주요 장비
    - **라우터** : IP 주소를 사용해 원격지까지 최적의 경로를 찾아주고 해당 경로로 패킷을 전송하는 역할을 한다.
    
    

### 4 계층 (Transport Layer)

- 하위 1,2,3 계층은 신호와 데이터를 올바른 위치로 보내고 실제 신호를 잘 만들어 보내는데 집중한다.
- 반면 4계층은 실제로 해당 데이터들이 **정상적으로 잘 보내지도록 확인**하는 역할을 한다.
    - 패킷 네트워크는 데이터를 분할해 패킷에 실어보내다 보니 중간에 패킷이 유실되거나 순서가 바뀌는 경우가 발생한다.
    - 4계층에서는 위와 같은 문제를 해결하기 위해 **패킷이 유실되거나 순서가 바뀌었을 때** 바로잡아주는 역할을 한다.
    - 패킷 헤더에
        - [보내는 순서를 명시한 **시퀀스 번호**] + [받는 순서를 명시한 **ACK 번호**)가 있다.
        - 또한 장치 내의 많은 어플리케이션을 구분할 수 있도록 **포트번호**를 사용한다.
- 주요 장비
    - (4계층) 로드밸런서
        - 포트 주소를 확인하는 동시에 IP 주소를 변경할 수 있다.
        - 주로 로드밸런서를 웹 서버 앞에 두고 웹 서버 여러 대를 두는 형식으로 사용된다 . 대표 IP는 로드 밸런서가 갖고 로드 밸런서가 각 웹 서버로 패킷의 목적지 IP 주소를 변경해 보내준다.
    - 방화벽
        - 방화벽을 통과하는 패킷의 3,4 계층 정보를 확인하고 패킷을 정책과 비교해 버리거나 포워딩한다.

### 5 계층 (Session Layer)

- 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고,
- 연결이 안정적으로 유지되도록 관리하고
- 작업 완료 후에는 이 연결을 끊는 작업을 한다 .
- TCP/IP 세션을 만들고 없애는 책임을 진다.
- 또한 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다 .

### 6 계층 (Presentation Layer)

- 표현 방식이 다른 애플리케이션이나 시스템 간의 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다. 일종의 번역기나 변환기 역할을 수행하는 계층
- MIME 인코딩이나 암호화, 압축, 코드 변환과 같은 동작이 이 계층에서 이뤄진다.

### 7 계층 (Application Layer)

- 애플리케이션 프로세스를 정의하고 애플리케이션 서비스를 수행한다.
- 네트워크 소프트웨어의 UI 부분이나 사용자 입,출력 부분을 정의하는 것이 애플리케이션 계층의 역할이다.
- 대표적인 프로토콜로 FTP, SMTP, HTTP, TELNET이 있다.



## TCP/IP 프로토콜 스택

### OSI 모델과의 비교

![image](https://user-images.githubusercontent.com/47748246/159610887-dcf5f129-f432-448d-8ef1-7481658ba285.png)

### 각 계층 간단 설명 + 프로토콜

- 애플리케이션
    - 네트워크 애플리케이션을 위한 프로토콜 지원
    - http, ssh, ftp, dns
    - 메시지를 생성, 트랜스포트 계층에 메시지 전송 부탁
- 트랜스포트
    - process to process 데이터 전송
    - tcp, udp
    - 인터넷 계층에 host 전송 부탁
- 인터넷
    - host to host 데이터 전송
    - 출발 → 목적지까지 routing
    - IP, routing protocol, arp(ip 주소를 mac 주소로 대응(bind)시키기 위해 사용되는 프로토콜), icmp (해당 **호스트가 없거나, 해당 포트에 대기중에 서버 프로그램이 없는** 등의 에러 상황이 발생할 경우 IP헤더에 기록되어 있는 출발지 호스트로 **이러한 에러에 대한 상황을 보내주는 역할을 수행)**
    - 네트워크 엑세스 계층에 한 홉 전송을 부탁
- 네트워크 엑세스
    - 인접한 네트워크 element 간의 데이터 전송

# 웹 통신의 큰 흐름

- 한 학생이 학교 캠퍼스 네트워크를 통해 www.google.com에 request를 보내고 response를 받는 과정

1. 인터넷에 접속하기
    - ip를 할당 받아야 함
    - first hop router의 ip 주소를 알아야 함
    - 구글의 도메인 이름은 알지만 ip 주소는 모르기 때문에 이를 알기 위한 dns 서버의 주소를 알아야함
    
    → DHCP 프로토콜을 통해 알아냄
    

<aside>
💡 DHCP 프로세스
1) DHCP 메시지는 로컬 네트워크에 broadcast 됨

2) DHCP 서비스를 탑재하고 있는 라우터가 broadcast된 DHCP 메시지에 관심을 가짐
    ⇒ DHCP 메시지를 받아서 DHCP ACK 메시지 생성 ⇒ broadcast 함

3) 학생 노트북은 해당 ACK 메시지가 자신이 보낸 쿼리에 대한 ACK이라는 것을 알고 DHCP ACK 메시지를 받음

4) 마침내 노트북은 자신의 IP 주소, gateway router의 IP 주소, DNS IP 주소를 알게된다.

</aside>

1. ARP
    - 주소창에 url 치는 순간, HTTP client 프로세스는 DNS client 프로세스를 구동시킴
    - DNS client는 www.google.com의 IP 주소를 물어보는 쿼리 메시지 작성
    - DNS 서버에 가기 위해서는 우선 first hop router를 거쳐야 함.
    - 하지만 현재 gateway router의 ip만 알고, 물리적 네트워크 주소(MAC 주소)는 모름
    - **ARP 쿼리를 broadcast하여 first hop router의 mac 주소를 알아냄**
    - 이후 dns 쿼리를 담고있는 메시지는 first hop router로 보내진다.

1. DNS 사용
    - IP datagram은 캠퍼스 네트워크에서 인터넷으로 broadcast 됨
    - 이때 **라우팅 프로토콜**들에 의해 생성된 라우팅 테이블을 통해 라우팅된다.
    - 그렇게 **DNS 서버에 도달하면 DNS 서버는 도메인 명에 대한 IP 주소를 담아서** 노트북에 **reply**
    - 이제 노트북은 구글의 IP 주소를 알게 되고, 웹 서버로 HTTP request를 보낼 준비가 됨.

1. TCP connection
    - application layer : http
    - transport layer : TCP : syn, synack, ack(+http msg) ⇒ 3 way handshake
    - Internet layer : (목적지) 웹 서버의 IP 주소
    - network access layer : (목적지)gateway router의 mac 주소

1. 구글 웹 서버에서 이 frame을 받으면 IP 계층까지 올려보냄 → 자신에게 온 것이 맞으면 HTTP reply 작성해서 client로 전송

# 그 외

## IP 주소 체계 : 클래스 기반 주소 지정


- IP 주소는 기본적으로 네트워크 주소와 호스트 주소로 나뉜다.
    - 네트워크 주소 : 호스트들을 모은 네트워크를 지칭하는 주소. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라 함
    - 호스트 주소 : 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소
- IP 주소의 네트워크 주소와 호스트 주소는 이 둘을 구분하는 경계점이 고정되어 있지 않다.
- IP 주소 체계는 필요한 호스트 IP 개수에 따라 네트워크의 크기를 다르게 할당할 수 있는 **클래스(Class)** 개념을 도입했다.
    - A 클래스는 첫 번째 옥텟에 네트워크 주소와 호스트 주소를 나누는 구분자를 가지며, B 클래스는 두번째 옥텟에, C 클래스는 세번째 옥텟에 구분자를 가진다.
        - 따라서 A 클래스는 약 1600만개의 IP 주소를 가질 수 있으며, B 클래스는 약 6만 5천개, C클래스는 약 250개의 IP 주소를 가질 수 있다.
    - 이 클래스 개념을 도입함으로써 IP 주소 체계는 다른 고정된 네트워크 주소 체계에 비해 주소를 절약할 수 있다.
        - 예 : 네트워크 크기가 모두 같은 경우, 큰 네트워크를 필요로하는 조직은 네트워크를 여러 개 확보해야 하는 어려움이 있고, 연속된 네트워크를 할당받기 어렵다. 작은 네트워크가 필요한 조직의 입장에서는 너무 많은 IP를 가져가므로 IP가 낭비된다.
    


## IP 부족 현상과 서브넷 마스크, NAT

### IP 부족 현상

- 기존 IPv4 주소 체계만으로는 기하급수적으로 늘어나는 IP 주소 요구를 감당하기에 부족
- 상위 클래스 (A Class)를 할당받은 조직에서 이 주소들을 제대로 사용하지 못하면서 낭비됨.
    - 클래스풀 주소 체계에서는 한 개의 클래스 네트워크가 한 조직에 할당되면 아무리 비어 있는 주소라도 IP를 분할해 다른 기관이 사용하도록 할 수 없었다.
    - 이 문제를 해결하기 위해 기존 클래스 단위로 네트워크와 호스트 부분을 나누는 것보다 더 세분화해서 나누고자 함. (= 서브네팅, 클래스리스 네트워크)
    - 서브넷 마스크를 이용해 나눈다.

### 클래스리스 네트워크와 서브넷 마스크

- 클래스리스 네트워크에서 별도로 네트워크와 호스트 주소를 나누는 구분자를 사용하는데 이 구분자를 서브넷 마스크(Subnet Mask)라고 부른다.
    
    

- 서브넷 마스크는 네트워크 주소는 2진수 숫자 1, 호스트 주소는 0으로 표현하여 구분한다.
- 서브넷 마스크를 이용해 IP 에서 네트워크 주소만 뽑아내는 방법은 다음과 같다.
    
    
- 예를들어, 103.9.32.146 주소에 255.255.255.0 서브넷 마스크를 사용하는 IP는 네트워크 주소가 103.9.32.0이고 호스트 주소는 0.0.0.146이 된다.
- 위 경우에 대해 IP 주소를 103.9.32.146/8 로 표현 가능하다. 여기서 8은 서브넷 마스크의 bit 수를 의미한다.

### NAT

- 네트워크 안의 서브넷을 나누는 역할은 라우터가 담당한다.
- 라우터는 공인 IP 주소를 할당 받은 장치
    - 서브넷 안의 호스트들은 가상 IP를 가짐
- 서브넷 안의 호스트들이 외부망인 인터넷에 데이터를 송수신할 경우, NAT (네트워크 주소 변환)을 통해 서브넷 가상 IP로 바꾸어주어 외부 서버와 호스트와의 통신을 가능하게 한다.
