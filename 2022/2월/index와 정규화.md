# Index

---

## Index란 무엇인가?

- 인덱스는 데이터베이스 테이블에 대한 **검색 성능의 속도를 높여주는** 자료 구조이다.
    - 인덱스 자료구조를 저장하기 위한 공간 비용이 발생한다.
    - Index를 이용해서 데이터베이스 테이블에 접근할 때마다 모든 row를 다 탐색하지 않고도 원하는 데이터를 빠르게 가져올 수 있다.

- 특정 컬럼에 대해 인덱스를 생성한다 = **해당 컬럼의 데이터들을 복사하여 정렬 + 데이터들이 실제로 저장된 위치를 별도의 메모리 공간에 저장**한다.
    - 이렇게 인덱스가 생성되면, 쿼리문에 “인덱스 컬럼을 where 조건으로 거는 등”의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있다
    - 인덱스는 키 컬럼 순으로 정렬되어 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다.
    - 이후 인덱스에 저장되어 있는 데이터의 물리적인 주소로 가서 데이터를 가져오는 방식으로 동작한다.

![image](https://user-images.githubusercontent.com/47748246/152806390-1528a9cd-ac54-487e-851b-1911a428db70.png)


## Index의 자료구조

- 인덱스에는 여러가지 유형이 있지만, 가장 많이 사용하는 인덱스 구조는 balanced tree (B TREE) 인덱스 구조이다.

![image](https://user-images.githubusercontent.com/47748246/152806428-bec6fa6d-bb3c-4fed-9307-2ae8656db07d.png)

- 구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node로 구성됩니다.
- **LEAF 블록**에 인덱스의 키가 되는 데이터와 데이터의 물리적 주소 정보인 ROWID를 저장합니다.

## 인덱스를 사용하는 이유

where 절을 이용한 검색 속도 향상

- 테이블의 레코드들은 내부적으로 순서가 없이 뒤죽박죽으로 저장된다. 따라서 index를 생성하지 않고 조회한다면 테이블의 모든 레코들을 조회하여 where 조건과 맞는지를 검사해야한다.
- 반면 index 테이블은 데이터들이 정렬되어 있기 때문에 where 조건에 맞는 데이터들을 빠르게 찾아낼 수 있다.

1. order by 정렬이 효율적
    - Order by는 1차적으로 메모리에서 정렬이 이루어지고, 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생하기 때문에 부하가 많이 걸리는 작업이다.
    - 하지만 인덱스 (index)를 사용하면 이미 정렬이 되어 있기 때문에 order by에 의한 sort 과정을 피할 수 있다.

## 인덱스의 단점

- 인덱스를 사용하면 **정렬된 상태를 계속 유지** 시켜줘야한다. 따라서 레코드 내 데이터 값이 바뀌는 경우 (insert, update, Delete가 발생하는 경우) index 테이블 내에 있는 값들을 다시 정렬해야함. 즉, 원본 테이블과 index 테이블 두 군데에 데이터 수정 작업을 해줘야 함
- 검색 시에도 항상 좋은 것은 아니다. 인덱스는 테이블의 전체 데이터 중에서 **10~15% 이하의 데이터를 처리하는 경우에만 효율적**이고 그 이상의 데이터를 처리할 때는 인덱스를 사용하지 않는 것이 더 낫다.
- 또한 인덱스를 관리하기 위해서 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다.

# 정규화

---

### 정규화란?

- 테이블 간의 **데이터 중복을 방지하기 위해** 테이블 간의 관계를 정의하는 것
- 데이터 중복이 문제가 되는 이유?
    - 저장 용량 낭비
    - 중복된 정보로 인한 `갱신 이상` 발생
        - 동일한 정보를 가진 테이블이 여러 개 존재한다고 할 때, 한 테이블의 정보가 변경되면 같은 방식으로 나머지 테이블의 정보도 변경해줘야 한다. 만약 그렇지 않다면 어느 것이 정확한 정보인지 알 수 없게 된다.
        - 삽입 이상 : 원하지 않는 자료가 삽입되거나, 삽입하는데 필수적인 데이터가 부족해 삽입이 되지 않아 발생하는 문제점을 말한다.
        - 삭제 이상 : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로써 원하지 않는 정보 손실이 발생하는 문제점을 말한다.
        - 수정 (갱신) 이상 : 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어지는 문제점을 말한다.

### 제 1 정규화

- 테이블의 **컬럼이 원자 값(Atomic Value, 하나의 값)을 갖도록** 테이블을 분해하는 것이다.
- 예를 들어 아래와 같은 고객 취미 테이블이 존재한다고 하자
    
    ![image](https://user-images.githubusercontent.com/47748246/152806644-3b3ce234-1a86-420d-8ecd-f61be883801c.png)
    
    위 테이블에서 추신수와 박세리는 하나의 컬럼에 여러 개의 취미를 가지고 있기 때문에 제 1 정규형을 만족하지 못하고 있다. 따라서 이를 제 1 정규화하여 분해할 수 있다. 제 1 정규화를 진행한 테이블은 아래와 같다.
    
    ![image](https://user-images.githubusercontent.com/47748246/152806685-223ba67a-8e4d-4a76-a0f3-9e9074428b58.png)
    

### 제 2 정규화

- 제 1 정규화를 진행한 테이블에 대해 **완전 함수 종속을 만족**하도록 테이블을 분해하는 것이다.
- **함수적 종속성**
    - 데이터들이 어떤 기준 값에 의해 종속되는 현상을 지칭하는 것
    - 이 때 기준 값을 결정자(Determinant)라 하고 종속되는 값을 종속자 (Dependent)라고 한다.
    - 결정자 → 종속자
        - 종속자는 결정자에 함수적으로 종속성을 가지고 있음
    - 주민등록번호 → (이름, 출생지, 주소)
        - 사람 이라는 엔터티는 주민등록번호, 이름, 출생지라는 속성이 존재한다. 여기서 이름, 출생지, 주소라는 속성은 주민등록번호 속성에 종속된다.
        - 이름, 출생지, 주소는 주민등록 번호에 함수 종속성을 가지고 있음
    
- 완전 함수 종속
    - 기본 키의 부분 집합이 결정자가 되어선 안된다는 것

예를 들어 아래와 같은 수강 강좌 테이블을 살펴보자

![image](https://user-images.githubusercontent.com/47748246/152806744-a2da242c-e288-4ec2-a5df-662ae0b78487.png)

- 기본 키 (primary key)
    - (학생번호, 강좌이름)으로 구성된 복합키
    - 이 기본 키는 성적을 결정한다.
    - (학생번호, 강좌이름) → (성적)
- 문제점
    - 그런데 여기서 강의실이라는 컬럼은 기본키의 부분 집합인 (강좌 이름)에 의해 결정될 수 있다.
    - (강좌이름) → (강의실).
        
        ⇒ 즉, 기본키 (학생번호, 강좌 이름)의 부분 키인 (강좌 이름)이 결정자
        
        ⇒ 완전 함수 종속에 어긋남
        
- 제 2 정규화
    - 기존 테이블에서 강의실을 분해해서 별도의 테이블로 관리한다.
    
    ![image](https://user-images.githubusercontent.com/47748246/152806789-8a8932c2-7f73-4323-a234-6edfe601afef.png)
    

### 제 3 정규화

- 제 2정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해하는 것
- 이행적 종속
    - A → B, B → C가 성립할 때 A→ C가 성립되는 것을 의미한다.

예를 들어, 아래와 같은 계절 학기 테이블을 살펴보자

![image](https://user-images.githubusercontent.com/47748246/152806816-4648c26d-a7b3-4589-b07d-e854f54a822f.png)

- 위 테이블에서 (학생번호)는 (강좌이름)을 결정하고, (강좌이름)은 (수강료)를 결정한다. 그래서 결국 (학생 번호)가 (수강료)를 결정하는 이행적 종속 형태가 된다.
- 따라서 이를 (학생번호, 강좌이름) 테이블과 (강좌이름, 수강료) 테이블로 분해함으로써 이행적 종속을 제거해야한다.
- 이행적 종속을 제거해야하는 이유?
    - 예를 들어, 501번 학생이 수강하는 강좌가 스포츠 경역학으로 변경되었다고 하자. 이행적 종속이 존재한다면 501번 학생은 스포츠 경역학이라는 수업을 20000원에 수강하게 된다. 물론 강좌 이름에 맞게 수강료를 다시 변경할 수 있지만, 이러한 번거로움을 해결하기 위해 제 3정규화를 하는 것이다.
    - 즉, 학생 번호를 통해 강좌 이름을 참조하고, 강좌 이름으로 수강료를 참조하도록 테이블을 분해해야 하며 그 결과는 다음 그림과 같다.
    
    ![image](https://user-images.githubusercontent.com/47748246/152806878-baf5d8bc-d12b-4cff-ab81-e663a4fdb466.png)
    

### BCNF 정규화

- 제 3정규화를 진행한 테이블에 대해 **모든 결정자가 후보키가 되도록** 테이블을 분해하는 것이다.

예를 들어 다음과 같은 특강 수강 테이블이 존재한다고 하자

![image](https://user-images.githubusercontent.com/47748246/152806935-49351c4f-e0e8-4355-838f-e453ebabe82c.png)

- 위 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키는 교수를 결정하고 있다. 또한 여기서 교수는 특강이름을 결정하고 있다.
- 여기서 문제는 **교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니라는 점**이다.
- 따라서 BCNF 정규화를 만족시키기 위해, 위의 테이블을 분해해야 한다. 다음과 같이 특강 신청 테이블과 특강 교수 테이블로 분해할 수 있다.

![image](https://user-images.githubusercontent.com/47748246/152806982-903bd3ec-2bd2-4bbf-8686-57cef89cd54e.png)
- 위 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키는 교수를 결정하고 있다. 또한 여기서 교수는 특강이름을 결정하고 있다.
