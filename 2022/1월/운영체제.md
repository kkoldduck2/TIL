# 동기와 비동기의 차이

### Blocking / NonBlocking

> 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사다.
> 
- Non blocking
    - 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 Non blocking이다.

- Blocking
    - 그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking이다.

### Synchronous / Asynchronous

> 호출되는 함수의 작업 완료 여부를 호출하는 함수가 신경쓰냐가 관심사다.
> 

호출하는 함수를 A, 호출되는 함수를 B라 할 때

- Asynchronous
    - A는 B를 호출할 때 callback을 함께 전달해서, B의 작업이 완료되면 전달받은 callback을 실행한다. 이때 A는 작업 완료 여부를 신경쓰지 않는다.
- Synchronous
    - A가 B의 작업 완료 후 리턴을 기다리거나, 또는 B로부터 바로 리턴 받더라도 작업 완료 여부를 A 스스로 계속 확인하며 신경쓴다.

![image](https://user-images.githubusercontent.com/47748246/151106515-11e46367-2322-458e-bba3-4347d282c1c4.png)

### Synchronous vs Blocking

- Synchronous
    - an activity that must wait for a reply before the thread can move forward
    - 작업을 요청한 후, 응답이 올 때까지 해당 쓰레드가 더 이상 진행되지 않는 것
- Blocking
    - the fact that the thread is placed in a wait state (= it will not be scheduled for execution untill some event occur)
    - 해당 쓰레드가 대기 큐에 들어가 wait state가 되는 것 (이벤트가 발생하기 전까지 스케쥴되지 않는다. )
- 즉, Synchronous는 그 구현 방식에 따라서 blocking behavior를 포함할 수도, 포함하지 않을 수도 있다.

[https://baek-kim-dev.site/38](https://baek-kim-dev.site/38)

# 프로세스 동기화

### Critical Section

- 공유 자원을 접근하는 코드 영역을 critical section이라 한다.

### Critical Section Problem

- 어떤 문제가 발생할 수 있는가?
    - A 프로세스가 공유 데이터를 변경하고 있는 동안 B 프로세스도 공유 데이터에 접근해서 데이터를 변경하고자 할 때
    - A : x+1 , B : x+2
    - 기대 값 x = x+3,  실제 결과 : x = x+1 이렇게 나올 수 있다.

### 해결을 위한 기본 조건

### 해결 방안

**1) Lock** - 하드웨어적 해결 방안

**2) Semaphore** - 소프트웨어적 해결 방안

# 메모리 관리 전략

### 메모리 관리 배경

### Paging

### Segmentation

# 가상 메모리

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법** 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

### 가상 메모리 등장 배경

### 가상 메모리가 하는 일

### Demand Paging (요구 페이징)

### 페이지 교체

# 캐시의 지역성
